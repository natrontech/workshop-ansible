{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#ansible-workshop","title":"Ansible Workshop","text":"<p>This workshop is a collection of materials that can be used to learn Ansible. The goal is to provide a quick overview of the most important concepts and tools. It's also a good starting point for self-study.  </p>"},{"location":"#goals","title":"Goals","text":"<ul> <li>Learn the basics of Ansible</li> <li>Get an overview of what Ansible is capable of</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li> A system capable of running Ansible (Linux, macOS, Windows(WSL))</li> </ul>"},{"location":"advanced/","title":"Ansible advanced","text":"<p>This section covers advanced topics of Ansible. Make sure you are familiar with the basics before you start with the advanced topics.</p>"},{"location":"advanced/ci-cd/ansible-runner/","title":"Ansible runner","text":"<p>Ansible runner allows you to abstract the execution of Ansible playbooks and roles. This is useful if you want to run Ansible playbooks in a CI/CD pipeline or if you want to run Ansible playbooks in a container.</p> <p>It makes sure that the Ansible environment is set up correctly and that the correct Ansible version is used. Ansible runner is also the tool that is used by Ansible tower and AWX to run Ansible playbooks.</p> <p>You can run Ansible runner in three ways:</p> <ul> <li>A standalone command line tool (ansible-runner) that can be started in the foreground or run in the background asynchronously</li> <li>A reference container image that can be used as a base for your own images and will work as a standalone container or running in Openshift or Kubernetes</li> <li>A python module - library interface</li> </ul>"},{"location":"advanced/ci-cd/ansible-runner/#reference","title":"Reference","text":"<p>Ansible runner</p>"},{"location":"advanced/ci-cd/gitlab-ci/","title":"GitLab CI/CD","text":"<p>You can use GitLab CI/CD to automatically build and test your project. This is a great way to ensure that your project is always in a working state.</p>"},{"location":"advanced/ci-cd/gitlab-ci/#setup-runner-image","title":"Setup runner image","text":"<p>You need to create a Docker image that contains all the tools you need to build and test your project. Here is an example dockerfile that you can use as a starting point: <pre><code>FROM python:3.10-bullseye\n\nCOPY requirements.txt requirements.txt\nCOPY requirements.yml requirements.yml\n\nRUN pip3 install -r requirements.txt\nRUN ansible-galaxy install -r requirements.yml\n</code></pre></p>"},{"location":"advanced/ci-cd/gitlab-ci/#setup-gitlab-cicd","title":"Setup GitLab CI/CD","text":"<p>To use GitLab CI/CD, you need to create a <code>.gitlab-ci.yml</code> file in the root of your project. This file contains the configuration for your CI/CD pipeline. You can find more information about the configuration file here.</p> <p>Here is an example <code>.gitlab-ci.yml</code> file that you can use as a starting point: <pre><code>stages:\n  - diff_infra\n  - deploy_infra\n\nworkflow:\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n\nvariables:\n  ANSIBLE_CONFIG: ./ansible.cfg\n  ANSIBLE_FORCE_COLOR: \"true\"\n\nimage:\n  name: myrepo/ansible-runner:1.0.0\n\nbefore_script:\n    - pip3 install -r ansible/requirements.txt\n    - ansible-galaxy install -r ansible/requirements.yml\n\ndiff infra:\n  tags:\n    - myrunner\n  stage: diff_infra\n  script:\n    - echo $VAULT_PW &gt; .vault-pass\n    - ansible-playbook ../../ansible/pb-infra.yml --check --diff\n\ndeploy infra:\n  tags:\n    - myrunner\n  stage: deploy_infra\n  script:\n    - echo $VAULT_PW &gt; .vault-pass\n    - ansible-playbook ../../ansible/pb-infra.yml\n</code></pre> This will first run a <code>diff</code> on your infrastructure and then deploy it. You can add more stages to your pipeline to run more tests or build your application.</p>"},{"location":"advanced/linting/ansible-lint/","title":"Ansible Lint","text":"<p>Ansible lint is a tool that checks playbooks for practices and behaviour that could potentially be improved.</p>"},{"location":"advanced/linting/ansible-lint/#installing-ansible-lint","title":"Installing ansible-lint","text":"<p>Ansible lint is a separate tool and can be installed with pip. It is not included in the Ansible package. You can use the following command to install ansible-lint: <pre><code>pip3 install ansible-lint\n</code></pre></p>"},{"location":"advanced/linting/ansible-lint/#configuring-ansible-lint","title":"Configuring ansible-lint","text":"<p>Ansible lint can be configured with a configuration file. The default location for the configuration file is <code>~/.ansible-lint</code>. Additionally you can configure exceptions in the file <code>~/.ansible-lint-ignore</code>.</p> ~/.ansible-lint-ignore<pre><code>path/myplaybook1.yml no-handler\npath/myplaybook2.yml command-instead-of-module\npath/myplaybook3.yml yaml[line-length]\n</code></pre>"},{"location":"advanced/linting/ansible-lint/#running-ansible-lint","title":"Running ansible-lint","text":"<p>You can run ansible-lint on a playbook with the following command: <pre><code>ansible-lint myplaybook.yml\n</code></pre> You can also create a git pre-commit hook to run ansible-lint on your playbooks before you commit them.</p>"},{"location":"advanced/linting/ansible-lint/#ansible-lint-in-vscode","title":"Ansible Lint in VSCode","text":"<p>If you install the Ansible extension for VSCode, you can use the ansible-lint to lint your playbooks. This only works if you have ansible-lint installed.</p> <p>The you need to make sure, that your yaml files are recognized as ansible files. </p> <p>The ansible-lint will show you validation errors in real time: </p>"},{"location":"advanced/linting/ansible-lint/#common-ansible-lint-errors","title":"Common ansible-lint errors","text":"Name Description <code>command-instead-of-module</code> the command module is used even though a possible ansible module exists <code>name</code> the name for a task or role is incorrect (missing, wrong casing, ...) <code>no_handler</code> when: result.changed is used instead of a handler <code>yaml</code> yaml is not valid (line lenght, trailing spaces, indentation, ...)"},{"location":"advanced/linting/ansible-lint/#reference","title":"Reference","text":"<p>Ansible Lint Ansible Lint rules</p>"},{"location":"advanced/linting/precommit/","title":"Pre-commmit hook for ansible lint","text":"<p>You can use a pre-commit hook to automatically lint your ansible files before you commit them. This is a great way to ensure that your ansible files are always in a working state.</p>"},{"location":"advanced/linting/precommit/#setup-pre-commit-hook","title":"Setup pre-commit hook","text":"<p>Setup your <code>.pre-commit-config.yaml</code> file to use the <code>ansible-lint</code> hook. You can find more information about the hook here.</p> .pre-commit-config.yaml<pre><code>repos:\n  - repo: https://github.com/ansible-community/ansible-lint\n    rev: v6.13.1\n    hooks:\n      - id: ansible-lint\n</code></pre> <p>Resulting output on a successful pre-commit hook:</p> <pre><code>user@host:~$ pre-commit   \nAnsible-lint..............................................Passed\n</code></pre> <p>Resulting output on a failed pre-commit hook:</p> <pre><code>Ansible-lint.............................................Failed\n- hook id: ansible-lint\n- exit code: 2\n\nINFO     Set ANSIBLE_LIBRARY=/home/myuser/.cache/ansible-compat/ds2asg/modules:/home/myuser/.ansible/plugins/modules:/usr/share/ansible/plugins/modules\nINFO     Set ANSIBLE_COLLECTIONS_PATH=/home/myuser/.cache/ansible-compat/ds2asg/collections:/home/myuser/.ansible/collections:/usr/share/ansible/collections\nINFO     Set ANSIBLE_ROLES_PATH=/home/myuser/.cache/ansible-compat/ds2asg/roles:/home/myuser/.ansible/roles:/usr/share/ansible/roles:/etc/ansible/roles\nINFO     Executing syntax check on playbook ansible/pb-cluster-setup.yml (0.61s)\nINFO     Executing syntax check on playbook ansible/pb-setup.yml (0.62s)\nWARNING  Listing 1 violation(s) that are fatal\nansible/roles/myrole/tasks/first.yml:42: name[casing]: All names should start with an uppercase letter.\n\nRead documentation for instructions on how to ignore specific rule violations.\n\n              Rule Violation Summary              \n count tag          profile  rule associated tags \n     1 name[casing] moderate idiom  \n</code></pre>"},{"location":"advanced/various/combine-when-loop/","title":"Combine when and loop","text":"<p><code>when</code> and <code>loop/with_items</code> can be combined to create a loop that only runs when a condition is met. This is useful when you want to loop over a list of items, but only run the task if the item meets a condition.</p>"},{"location":"advanced/various/combine-when-loop/#loop-over-a-list-of-items","title":"Loop over a list of items","text":"<p>You can add a list directly in the task and loop over it. This will loop over all names except for <code>bob</code>. <pre><code>tasks:\n  - name: create users\n    user:\n      name: \"{{ item }}\"\n    loop:\n      - alice\n      - bob\n      - charlie\n    when: item != 'bob'\n</code></pre></p>"},{"location":"advanced/various/combine-when-loop/#loop-over-magic-variables","title":"Loop over magic variables","text":"<p>You can also loop over magic variables like <code>groups</code> or <code>hostvars</code>. This is for example if you want to loop over all hosts in a group except for the current host itself.</p> <p>Here we loop over all hosts in the <code>dns</code> group except for the current host itself. This will allow dns replicaton traffic(tcp 53) from all dns hosts to the master (first member of the <code>dns</code> group) host.</p> <p>Based on your needs you can use an Ansible playbook or the rules.j2 template.</p> playbook.ymlrules.j2 <pre><code>- name: iptables | dns server traffic\niptables:\n    chain: INPUT\n    source: \"{{ hostvars[item]['ansible_host'] }}\"\n    protocol: tcp\n    destination_port: \"53\"\n    jump: ACCEPT\nwhen: \n    - inventory_hostname == hostvars[groups['dns'][0]]['inventory_hostname']\n    - inventory_hostname != hostvars[item]['inventory_hostname']\nloop: \"{{ groups.dns }}\"\nnotify:\n    - iptables | save\n</code></pre> <pre><code>{% if inventory_hostname in groups['dns'][0] %}\n{% for h in groups['dns'] %}\n{% if inventory_hostname not in hostvars[h]['inventory_hostname'] %}\nip saddr {{hostvars[h]['ansible_host']}} tcp dport 53 counter accept\n{% endif %}\n{% endfor %}\n{% endif %}\n</code></pre>"},{"location":"advanced/various/global-vars/","title":"Making variables global","text":"<p>Before the playbook starts, Ansible will always render variables directly to the hosts. With modules like <code>set_fact</code> and <code>register</code> you can set variables for the hosts you are iterating over.</p> <p>In some cases you might want to set variables globally, so that they are available for all hosts. This is not possible but there is a workaround for this.</p> <p>Example use cases are:</p> <ul> <li>Create a single cluster join token for all hosts to use in a playbook</li> <li>Create a git commit if any network device has changed configuration</li> </ul>"},{"location":"advanced/various/global-vars/#workaround","title":"Workaround","text":"<p>You can use your localhost as a variable storage and reference the variables from there. Just run a <code>set_fact</code> task on your localhost and set <code>delegate_facts</code> set to <code>true</code>. Reference the fact in any play like this <code>hostvars['localhost']['my_global_var']</code>. In case the variable is not set we need to specify a default value so the playbook doesn't fail.</p> <p>Here are some examples for the use cases above:</p> Generate a token if cluster join is pending<pre><code>- name: Stat | does config exist?\n  ansible.builtin.stat:\n    path: /etc/mycluster.config\n  register: _join_config\n\n- name: Set fact | is any cluster join pending?\n  ansible.builtin.set_fact:\n    cluster_join_pending: true\n  delegate_to: localhost\n  delegate_facts: true\n  when: not _join_config.stat.exists\n\n- name: Command | create join token for all pending joins\n  ansible.builtin.command:\n    cmd: cluster token create\n  delegate_to: \"{{ groups.master[0] }}\"\n  register: token\n  run_once: true\n  when: hostvars['localhost']['cluster_join_pending'] is true | default(false)\n</code></pre> Git commit if any config changed<pre><code># Play for network devices\nhosts: routers\n\nrouter_config:\n  backup: yes\n  backup_options:\n  filename: \"{{ inventory_hostname }}.cfg\"\n  dir_path: /mybackup \nregister: configbkp\n\nset_fact:\n configchange: true\ndelegate_to: localhost\ndelegate_facts: true\nwhen: configbkp.changed\n\n#Next play for localhost\nhosts: localhost\ngather_facts: true # required to keep fact from play above\n\nshell:\n  chdir: /data/ansible/cisco/backup\n  cmd: \"git add .\"\nwhen: configchange | default(false)\n\nshell:\n  cmd: git commit -m \"Ansible backup\"\nwhen: configchange | default(false)\n</code></pre>"},{"location":"advanced/various/loop-until/","title":"Looping until a condition is met","text":"<p>Looping in ansible is very powerful. If you combine looping with the <code>until</code> conditional you can create usefull playbooks. In this section we will look at some examples of how to use looping with <code>until</code>.</p> <p><code>ignore_errors</code> is a very useful option to use with <code>until</code>. It will ignore any errors that occur during the loop. This is very useful if you want to wait for a service to come online. If the service is not yet online the loop will fail. If you use <code>ignore_errors</code> the loop will continue until the condition is met.</p>"},{"location":"advanced/various/loop-until/#continue-if-website-is-online","title":"Continue if website is online","text":"<p>Wait for a website to come online and continue only then.</p> Wait for a website to come online<pre><code>- shell:\n    cmd: curl --connection-timeout 2 http://localhost\n  register: result\n  until: result is succeeded\n  retries: 10\n  delay: 30\n  ignore_errors: true\n</code></pre>"},{"location":"advanced/various/loop-until/#configure-a-windows-domain-controller","title":"Configure a windows domain controller","text":"<p>If you configure a windows domain controller after the first reboot the connection might already be established, but the domain services are not yet ready. We want to only continue when the domain services are ready.</p> Configure a windows domain controller<pre><code>#Wait for DC to be back after promotion\n- name: Wait for domain controller to be ready\n  win_shell: |\n    Get-ADDomain mydomain.com\n  register: dc_ready\n  until: dc_ready is not failed\n  ignore_errors: yes\n  retries: 180\n  delay: 5\n</code></pre>"},{"location":"advanced/various/quoting/","title":"Quoting","text":"<p>Quoting in Ansible can be a bit tricky. This page will give you a quick overview of the different types of quoting and how to use them.</p>"},{"location":"advanced/various/quoting/#referencing-variables-in-a-playbook","title":"Referencing variables in a playbook","text":"<p>In playbooks you can use Jinja2 templating language to reference variables. Playbooks need to be valid YAML, so you need to quote the variables in a way that YAML understands. Most of the time you can use double quotes <code>\"</code> and single quotes <code>'</code> on playbooks interchangeably.</p> <p>Some keywords like <code>when</code> and <code>register</code> expect variables and therefore you don't need to quote there.</p> Correct exampleIncorrect example <pre><code>debug:\n  msg: '{{ mymessage }}/foo.cfg'\n\ndebug:\n  msg: \"{{ mymessage }}/foo.cfg\"\n\n# Here we don't need to quote the variable\nwhen: inventory_hostname in groups['webserver']\nregister: myvar\n</code></pre> <pre><code>debug:\n  msg: {{ mymessage }}/foo.cfg # (1)!\n</code></pre> <ol> <li>This playbook will fail with an error like     <pre><code> The offending line appears to be:\n debug:\n     msg: {{ mymessage }}\n         ^ here\n\n     We could be wrong, but this one looks like it might be an issue with\n     missing quotes. Always quote template expression brackets when they\n     start a value. For instance:\n\n         with_items:\n         - {{ foo }}\n\n     Should be written as:\n\n         with_items:\n         - \"{{ foo }}\"\n</code></pre></li> </ol>"},{"location":"advanced/various/quoting/#multiple-types-of-quotes","title":"Multiple types of quotes","text":"<p>If you need to to define quotes itself in a line, you need to use differents quotes arround the string.</p> <p>The desired command to be run is: <pre><code>echo 'Hello &lt;name&gt;'\n              ^ Variable in ansible\n</code></pre></p> <p>Here we need to add multiple quotes so that ansible knows how to formulate the command. <pre><code>shell:\n    cmd: \"echo 'Hello {{ name }}'\"\n</code></pre></p>"},{"location":"advanced/various/quoting/#referencing-variables-in-a-jinja2-template","title":"Referencing variables in a Jinja2 template","text":"<p>Jinja templates(<code>.j2</code>) are are not parsed as YAML and therefore don't require quoting like ansible playbooks.</p> template.j2<pre><code>Hello {{ mymessage }}\n</code></pre>"},{"location":"advanced/various/quoting/#when-to-quote","title":"When to quote","text":"<p>Sometimes you don't need to quote variables.</p> <p>Here is an example using the <code>when</code> keyword in YAML: playbook.yml<pre><code># Only run when the current host is the same as the host in the loop\nwhen: inventory_hostname == hostvars[item]['inventory_hostname']\n</code></pre> This can be confusing, so let's break it down:</p> Name Description <code>inventory_hostname</code>  A variable referencing the current host <code>==</code>  Equal operation <code>hostvars[]</code>  A function calling hostvariables of a certain host <code>item</code>  A variable referencing the current item in the loop <code>'inventory_hostname'</code>  Is a sting referencing the variable name that we want to access from  the <code>hostvars[]</code> funtion <p>This is similar in Jinja2 templates. Here is an example that is even more tricky: template.j2<pre><code># Set the last host in the dns group as the master\n{% if inventory_hostname in hostvars[groups['dns']|last]['inventory_hostname'] %}\n  master = true\n{% endif %}\n</code></pre></p> <p>Again let's break it down:</p> Name Description <code>inventory_hostname</code>  A variable referencing the current host <code>in</code>  In operation (is this string in the compare value?) <code>hostvars[]</code>  A function calling hostvariables of a certain host <code>groups[]</code>  A function calling groupmembers of a certain group <code>'dns'</code>  A string referencing the name of the group we want to get <code>|last</code>  A Jinja2 filter extracting the last item in a list <code>'inventory_hostname'</code>  Is a sting referencing the variable name that we want to access from  the <code>hostvars[]</code> funtion"},{"location":"advanced/various/quoting/#reference","title":"Reference","text":"<p>Ansble docs - quoting</p>"},{"location":"advanced/various/rc-in-command/","title":"Making the command module indempotent","text":"<p>The ansible <code>command</code> and <code>shell</code> modules are special in that they are not idempotent. This means that if you run the same command twice, it will run the command twice. This is not always desirable. For example, if you are running a command that creates a file, you may not want to run it again if the file already exists. This is where the <code>creates</code> and <code>removes</code> options come in. If you are not working with files you will need to make the command idempotent itself or create your own Ansible module.</p>"},{"location":"advanced/various/rc-in-command/#making-the-command-indempotent-itself","title":"Making the command indempotent itself","text":"<p>You can write your command so, that is returns a specific exit code if the final state is already met. This is a good option if no Ansible module is available and you don't want to write one on your own.</p> <p>This code will create an OU in Active Directory if it does not exist. If the OU already exists, it will return exit code 1001. Which results in the task showing status <code>ok</code> instead of <code>changed</code>. <pre><code>- name: Shell | create OU if it does not exist\n  win_shell: |\n    if (Get-ADOrganizationalUnit -Filter 'distinguishedName -eq \"ou={{ my_ou_name }},dc=domain,dc=com\"') \n    { Exit 1001 } else { \n    New-ADOrganizationalUnit -Name '{{ my_ou_name }}' -Path 'dc=domain,dc=com'\n    }\n  register: ou\n  changed_when: ou.rc == 0\n  failed_when: ou.rc == 1\n</code></pre></p>"},{"location":"advanced/various/rc-in-command/#creates-removes","title":"Creates / removes","text":"<p>Creates will only run a command if a certan file does not exist. If the file exists, the command will not run. <pre><code>- name: Run command if /path/to/database does not exist (with 'args' keyword)\n  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name\n  args:\n    creates: /path/to/database\n</code></pre></p> <p>Removes will only run a command if a certan file does exist. If the file doesn't exist, the command will not run. <pre><code>- name: Run command if /path/to/database does exist (with 'args' keyword)\n  ansible.builtin.command: rm /path/to/database\n  args:\n    removes: /path/to/database\n</code></pre></p>"},{"location":"advanced/various/rc-in-command/#reference","title":"Reference","text":"<p>Ansible docs - command module</p>"},{"location":"basics/","title":"Ansible basics","text":"<p>This section will help you to get started with Ansible. It will explain the basic concepts and how to use Ansible to manage your infrastructure.</p>"},{"location":"basics/control-flow/block/","title":"Blocks","text":"<p>With blocks you can group multiple statements into a single compound statement. Blocks are useful when you want to run a set of tasks only if a certain condition is met. If you are running a playbook in serial mode (one host at a time), you can also use blocks to run a set of tasks on a single host before moving on to the next host.</p>"},{"location":"basics/control-flow/block/#block-of-tasks","title":"Block of tasks","text":"<p>This task will run on CentOS only. <pre><code>tasks:\n    - name: Install, configure, and start Apache\n      when: ansible_facts['distribution'] == 'CentOS'\n      block:\n      - name: Install httpd and memcached\n        ansible.builtin.yum:\n          name:\n          - httpd\n          - memcached\n          state: present\n\n      - name: Apply the foo config template\n        ansible.builtin.template:\n          src: templates/src.j2\n          dest: /etc/foo.conf\n\n      - name: Start service bar and enable it\n        ansible.builtin.service:\n          name: bar\n          state: started\n          enabled: True\n</code></pre></p>"},{"location":"basics/control-flow/block/#always-and-rescue","title":"Always and rescue","text":"<p>Always and rescue are similar to <code>try/catch/finally</code> in other languages like Powershell. The rescue block will run if any of the tasks in the block fail. The always block will always run, regardless of whether the block or rescue block ran.</p> <pre><code>- name: Attempt and graceful roll back demo\n  block:\n    - name: Print a message\n      ansible.builtin.debug:\n        msg: 'I execute normally'\n\n    - name: Force a failure\n      ansible.builtin.command: /bin/nonexistent\n\n  rescue:\n    - name: Print when errors\n      ansible.builtin.debug:\n        msg: 'I caught an error'\n\n    - name: Force a failure in middle of recovery!\n      ansible.builtin.command: /bin/nonexistent\n\n  always:\n    - name: Always do this\n      ansible.builtin.debug:\n        msg: \"This always executes\"\n</code></pre>"},{"location":"basics/control-flow/block/#reference","title":"Reference","text":"<p>Ansible docs - Blocks</p>"},{"location":"basics/control-flow/contitionals/","title":"Using when in ansible tasks","text":"<p>The <code>when</code> allows you to run ansible task only when a condition is met.</p>"},{"location":"basics/control-flow/contitionals/#based-on-variables","title":"Based on variables","text":"<p>Run a certain task only when a certain variable is set.</p> <pre><code>tasks:\n  - name: Configure SELinux to start mysql on any port\n    ansible.posix.seboolean:\n      name: mysql_connect_any\n      state: true\n      persistent: true\n    when: ansible_selinux.status == \"enabled\"\n</code></pre>"},{"location":"basics/control-flow/contitionals/#based-on-magic-variables","title":"Based on magic variables","text":"<p>Run a certain task only when the hosts meets a certain criteria.</p> <pre><code>tasks:\n  - name: my task\n    ...\n    when: \n\n    # Host is in the group 'web'\n    - \"'web' in group_names\"\n\n    # Host is the first member of the group 'db'\n    - inventory_hostname == groups['db'][0]\n\n    # Host is the last member of the group 'dc'\n    - inventory_hostname == hostvars[groups['dc']|last]['inventory_hostname']\n</code></pre>"},{"location":"basics/control-flow/contitionals/#based-on-ansible-facts","title":"Based on ansible facts","text":"<p>Run a certain task only when a certain fact is set.</p> <pre><code>tasks:\n  - name: Shut down Debian systems\n    ansible.builtin.command: /sbin/shutdown -t now\n    when: ansible_facts['os_family'] == \"Debian\"\n</code></pre>"},{"location":"basics/control-flow/contitionals/#combine-conditions","title":"Combine conditions","text":"<p>You can combine conditions using <code>and</code> and <code>or</code>.</p> <pre><code>tasks:\n  - name: my task\n    ...\n    when: \n\n    # Host is in the group 'web' and in the group 'db'\n    - \"'web' in group_names\"\n    - \"'db' in group_names\"\n\n    # Host is in the group 'web' or debian based\n    - \"'web' in group_names or ansible_facts['os_family'] == 'Debian'\"\n</code></pre>"},{"location":"basics/control-flow/contitionals/#reference","title":"Reference","text":"<p>Ansible docs - conditionals</p>"},{"location":"basics/control-flow/execution-strategy/","title":"Exection strategy","text":"<p>By default ansible will run tasks in parallel and continue to the next task as soon as all hosts have finished the current task. This is called the <code>linear</code> strategy. This is the default strategy and is the best choice for most use cases.</p>"},{"location":"basics/control-flow/execution-strategy/#change-strategy","title":"Change strategy","text":"<p>Another common strategy is <code>free</code>. This strategy will run tasks in parallel and not wait for all hosts to finish before moving on to the next task. This is useful when you want to run a playbook as fast as possible.</p> <pre><code>- hosts: all\n  strategy: free\n  tasks:\n  # ...\n</code></pre>"},{"location":"basics/control-flow/execution-strategy/#forks","title":"Forks","text":"<p>By default ansible is configured with 5 forks. This means that ansible will run 5 tasks in parallel on each host. You can change this number by setting the <code>forks</code> variable. This requires more compute resources on the ansible control node.</p> ansible.cfg<pre><code>[defaults]\nforks = 30\n</code></pre>"},{"location":"basics/control-flow/execution-strategy/#serial","title":"Serial","text":"<p>Serial will limit the amount of hosts that ansible will run tasks on in parallel. Compared to forks, serial can be configured with a percentage of all hosts involved in the play.</p> <pre><code>- name: run a play on max. 30% of all hosts at the same time\n  hosts: webservers\n  serial: \"30%\"\n</code></pre>"},{"location":"basics/control-flow/execution-strategy/#run-once","title":"Run once","text":"<p>If you want to run a task only on one host, you can use the <code>run_once</code> option. All gathered facts will be applied to all hosts of the play. By default ansible will run the task on the first host in the inventory. You can override this by setting the <code>delegate_to:</code>.</p> <pre><code>- command: python3 ./upgrade_database.py\n  run_once: true\n  delegate_to: webserver1\n</code></pre>"},{"location":"basics/control-flow/execution-strategy/#order-of-execution","title":"Order of execution","text":"<p>By default ansible will execute the taks in order of the hosts listed in the inventory. You can change this by setting the <code>order</code> option.</p> <pre><code>- hosts: all\n  order: sorted\n  tasks:\n  # ...\n</code></pre> <p>Possible values are:</p> <ul> <li><code>inventory</code>: Use the order of hosts in the inventory</li> <li><code>reverse_inventory</code>: Use the order of hosts in the inventory in reverse order</li> <li><code>sorted</code>: Sort hosts by name</li> <li><code>reverse_sorted</code>: Sort hosts by name in reverse order</li> <li><code>shuffle</code>: Randomize the order of hosts each play</li> </ul>"},{"location":"basics/control-flow/execution-strategy/#reference","title":"Reference","text":"<p>Ansible docs - Execution strategy</p>"},{"location":"basics/control-flow/import/","title":"Import und include","text":"<p>Import and include allow you to reuse files from other roles or playbooks.</p> <ul> <li>All import statements are pre-processed at the time playbooks are parsed.</li> <li>All include statements are processed as they are encountered during the execution of the playbook.</li> </ul>"},{"location":"basics/control-flow/import/#include-a-task","title":"Include a task","text":"<p>Include the task mytask.yml from the current folder. main.yml<pre><code>- name: Include a task from this folder\n  ansible.builtin.include_tasks: mytask.yml\n\n- name: Include another task from this folder\n  ansible.builtin.include_tasks: anothertask.yml\n</code></pre></p>"},{"location":"basics/control-flow/import/#include-a-role","title":"Include a role","text":"<p>Include the role myrole in the current playbook. playbook.yml<pre><code>- name: Include a role\n  ansible.builtin.include_role:\n    name: myrole\n</code></pre></p>"},{"location":"basics/control-flow/import/#include-a-task-from-a-role","title":"Include a task from a role","text":"<p>Restart the webservice using a task from the role webserver. playbook.yml<pre><code>- name: Role | webserver\n  ansible.builtin.include_role:\n    name: webserver\n    tasks_from: restart-webservice\n</code></pre></p>"},{"location":"basics/control-flow/import/#reference","title":"Reference","text":"<p>Ansible docs - Importing and Including</p>"},{"location":"basics/control-flow/loop/","title":"Looping","text":"<p>Ansible allows you to loop over a list of items. You can reference the current item using the <code>item</code> variable. Looping can get very complex, so we will only cover the basics here. If you are interested in more advanced looping, check out reference at the end of this page.</p>"},{"location":"basics/control-flow/loop/#loop-over-a-list-of-items","title":"Loop over a list of items","text":"<p>You can add a list directly in the task and loop over it. <pre><code>tasks:\n  - name: create users\n    user:\n      name: \"{{ item }}\"\n    loop:\n      - alice\n      - bob\n      - charlie\n</code></pre></p>"},{"location":"basics/control-flow/loop/#loop-over-a-multivalued-list","title":"Loop over a multivalued list","text":"<p>If your list has keys and values, you can reference them using the <code>item.key</code> variable. <pre><code>- name: Add several users\n  ansible.builtin.user:\n    name: \"{{ item.name }}\"\n    state: present\n    groups: \"{{ item.groups }}\"\n  loop:\n    - { name: 'testuser1', groups: 'wheel' }\n    - { name: 'testuser2', groups: 'root' }\n</code></pre></p>"},{"location":"basics/control-flow/loop/#loop-over-a-variable","title":"Loop over a variable","text":"<p>You can also loop over a variable that contains a list. <pre><code>- name: Add multiple packages\n  ansible.builtin.apt:\n    name: \"{{ item }}\"\n    state: present\n  loop:\n    - \"{{ packages }}\"\n</code></pre></p>"},{"location":"basics/control-flow/loop/#loop-over-magic-variables","title":"Loop over magic variables","text":"<p>You can also loop over magic variables like <code>groups</code> or <code>hostvars</code>. <pre><code>- name: Show all the hosts in the inventory\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  loop: \"{{ groups['all'] }}\"\n</code></pre></p>"},{"location":"basics/control-flow/loop/#control-the-output-if-loops","title":"Control the output if loops","text":"<p>Bt default Ansible will show all properties of the looped items in the output. You can control the console output of loops using the <code>loop_control</code> option. <pre><code>user:\n  name: \"{{ item.username }}\"\n  uid: \"{{ item.uid }}\"\n  home: \"{{ item.home }}\"\n  password: \"{{ item.password | password_hash('sha512') }}\"\nwith_items: \"{{ csv_users.list }}\"\nloop_control:\n  label: \"{{ item.username }}\"\n</code></pre></p>"},{"location":"basics/control-flow/loop/#reference","title":"Reference","text":"<p>Ansible docs - Loops</p>"},{"location":"basics/inventory/create-inventory/","title":"Creating an ansible inventory","text":"<p>The inventory is a file that contains a list of hosts, groups and optionally variables. The inventory file can be a YAML file or an INI file. This tutorial uses YAML format.</p>"},{"location":"basics/inventory/create-inventory/#creating-the-inventory","title":"Creating the inventory","text":"<p>This is an example inventory file. It contains 3 hosts and 1 group. The group <code>webserver</code> contains only server2. inventory.yml<pre><code>all:\n  vars:\n    my_variable: \"Hello World\"\n  hosts:\n    server1:\n    server2:\n    server3:\n  children:\n    webserver:\n      hosts:\n        server2:\n</code></pre></p> <p>The inventory always has a global group called <code>all</code> and there are 3 sub groups</p> <ul> <li><code>hosts</code> a list of hosts</li> <li><code>vars</code> a list of variables</li> <li><code>children</code> a list of child groups with their members.</li> </ul>"},{"location":"basics/inventory/create-inventory/#configure-ansible-to-use-the-inventory","title":"Configure ansible to use the inventory","text":"<p>A file called <code>ansible.cfg</code> in your working directory is required to reference the inventory file. The file should look like this: ansible.cfg<pre><code>[defaults]\ninventory = ./inventory.yml\n</code></pre></p>"},{"location":"basics/inventory/validate-inventory/","title":"Validating","text":""},{"location":"basics/inventory/validate-inventory/#show-the-inventory","title":"Show the inventory","text":"<p>Run the following command to show the inventory: <pre><code>ansible-inventory --list --yaml\n</code></pre></p> <p>Note</p> <p>Notice how the variables are inherited from the parent groups.</p> outputinventory.yml <pre><code>all:\n  children:\n    ungrouped:\n      hosts:\n        webserver1:\n          web_color: green #(1)!\n        webserver3:\n          web_color: orange #(2)!\n    webserver:\n      hosts:\n        webserver2:\n          web_color: blue #(3)!\n</code></pre> <ol> <li>This variable was defined for the host <code>webserver1</code> directly</li> <li>This variable was defined in the group <code>all</code> and inherited by the host <code>webserver3</code></li> <li>This variable was defined in the group <code>webserver</code> and inherited by the host <code>webserver2</code></li> </ol> <pre><code>all:\n  hosts:\n    webserver1:\n        web_color: \"green\"\n    webserver2:\n    webserver3:\n  vars:\n    web_color: \"orange\"\n  children:\n    webserver:\n      vars:\n        web_color: \"blue\"\n      hosts:\n        webserver2:\n</code></pre>"},{"location":"basics/inventory/variables/","title":"Variables","text":"<p>Ansible variables can be defined directly in the inventory file. This is useful for defining variables that are common to all hosts in a group. For example, you can define a variable called <code>ansible_user</code> to specify the user to use when connecting to the hosts in a group.</p> <p>If you have a lot of variables you can write them into a separate file and include it in the inventory file. This is useful for keeping the inventory file clean and readable.</p> <p>Attention</p> <p>Variables will always be rendered directly to the hosts before you run a playbook. This means that ansible itself has no global variables that can be modified for all hosts at runtime. In the advanced section you will learn how to make variables usable across different hosts.</p>"},{"location":"basics/inventory/variables/#defining-variables-in-the-inventory-file","title":"Defining variables in the inventory file","text":"<p>You can define variables globally, for a group or for a host. The variable defined closest to the host will always take precedence. inventory.yml<pre><code>all:\n  hosts:\n    webserver1:\n        web_color: \"green\"\n    webserver2:\n    webserver3:\n  vars:\n    web_color: \"orange\"\n  children:\n    webserver:\n      vars:\n        web_color: \"blue\"\n      hosts:\n        webserver2:\n</code></pre></p>"},{"location":"basics/inventory/variables/#defining-variables-in-a-separate-file","title":"Defining variables in a separate file","text":"<p>You can define variables in separate files. This is useful for keeping the inventory file clean and readable. The folders <code>group_vars</code> and <code>host_vars</code> in your working directory can be used to assign variables per host or group.</p> Host variable filesGroup variable files host_vars/server1.ymlhost_vars/localhost.yml <pre><code>my_var_for_server1: \"Hello World\"\n</code></pre> <pre><code>my_var_for_localhost: \"Hello World\"\n</code></pre> group_vars/webserver.ymlgroup_vars/all.yml <pre><code>my_var_for_all_webservers: \"Hello World\"\n</code></pre> <pre><code>my_var_for_all_hosts: \"Hello World\"\n</code></pre>"},{"location":"basics/inventory/variables/#magic-variables","title":"Magic Variables","text":"<p>Magic variables are variables that are automatically set by Ansible, they are not set in your inventory file. These variables are very important because they are used a lot in ansible playbooks and roles.</p> <p>Some good examples for magic variables are:</p> Variable Content <code>hostvars</code> A dictionary/map with all the hosts in inventory and variables assigned to them <code>group_names</code> List of groups the current host is part of <code>groups</code> A dictionary/map with all the groups in inventory and each group has  the list of hosts that belong to it <code>inventory_hostname</code> The inventory name for the \u2018current\u2019 host being iterated  over in the play <p>Ansible Reference: https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html#magic-variables</p>"},{"location":"basics/jinja/filter/","title":"Jinja2 Filters","text":"<p>Jinja2 filters are functions that can be applied to content in a Jinja2 template.  Filters can be chained together, just like functions in normal coding languages like python.</p>"},{"location":"basics/jinja/filter/#loop","title":"Loop","text":"<p>The <code>loop</code> function can be used to loop over a list of items.</p> <pre><code>{% for host in groups['web'] %}\nServer Hostname: {{ hostvars[host]['inventory_hostname'] }}\nServer IP: {{ hostvars[host]['ansible_host'] }}\n{% endfor %}\n</code></pre>"},{"location":"basics/jinja/filter/#if-else-statement","title":"If else statement","text":"<p>Only add certain content to the template, if a condition is met. <pre><code>zone \"mydomain.com\" {\n\n{% if inventory_hostname in groups['dns'][0] %}\ntype master;\n\n{% else %}\ntype slave;\n\n{% endif %}\n\n};\n</code></pre></p>"},{"location":"basics/jinja/filter/#reference","title":"Reference","text":"<p>Jinja offers a lot of templating functions. You can find more information in their documentation: Jinja 2 docs</p>"},{"location":"basics/jinja/variables/","title":"Jinja2 variables","text":"<p>Jinja2 is a templating lanugage that Ansible uses to create dynamic templates. The main usecase for Jinja2 is the ansible <code>template</code> module. See the template module section for more information.</p> <p>Templating can be usefull for generating configuration files, or for creating files with dynamic content. Good examples are webserver configuration files, systemd service files or even static HTML files.</p> <p>All variables in Ansible can be accesses from within a Jinja2 template.</p>"},{"location":"basics/jinja/variables/#accessing-variables","title":"Accessing variables","text":"<p>You can access variables from within a Jinja2 template by using the <code>{{ variable_name }}</code> syntax.</p> <pre><code>The time on this host is {{ ansible_date_time.date }}\n</code></pre> <p>You can also access the ansible magic variables like <code>hostvars</code> and <code>groups</code>:</p> <pre><code>The host {{ inventory_hostname }} is in these groups {{ group_names }}\n</code></pre>"},{"location":"basics/jinja/variables/#reference","title":"Reference","text":"<p>Jinja 2 docs</p>"},{"location":"basics/modules/debug/","title":"Debug module","text":"<p>The ansible debug module allows you to print variables to the console. This is useful for debugging.</p>"},{"location":"basics/modules/debug/#debugging-variables","title":"Debugging variables","text":"<p>This is an example tasks, that will print the variable <code>my_var</code> to the console. <pre><code>- name: \"Print variable\"\n  debug:\n    var: my_var\n</code></pre></p>"},{"location":"basics/modules/debug/#debugging-text","title":"Debugging text","text":"<p>This is an example tasks, that will print the variable <code>my_var</code> to the console. <pre><code>- name: \"Print variable\"\n  debug:\n    msg: \"This is a text ending with a variable {{ my_var }}\"\n</code></pre></p>"},{"location":"basics/modules/debug/#reference","title":"Reference","text":"<p>Ansible docs - debug module</p>"},{"location":"basics/modules/template/","title":"Template module","text":"<p>Ansible Docs reference: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html</p> <p>The template module is one of the most powerful modules in Ansible. It allows you to create files from templates. The template module is a wrapper around Jinja2, a templating language for Python. The template module is used to create configuration files, or any text files that require variables injected into them. Template files have the extension <code>.j2</code>.</p> <p>The template file is also indempotent.  If the file already exists, it will only be changed if the template file has changed.</p> <p>Good examples for using templates are:</p> <ul> <li>Nginx Config file</li> <li>Firewall rule set</li> <li>Hosts file</li> </ul>"},{"location":"basics/modules/template/#creating-a-template","title":"Creating a template","text":"<p>This is an example for a hosts file template. It will be used to create a hosts file on the remote system.</p> <p>Create hosts file with all webservers</p> hosts.j2inventory.ymlplaybook.ymlhosts file server1hosts file server2hosts file server3 <pre><code># localhost\n127.0.0.1 localhost\n{{ ansible_host }} {{ inventory_hostname }}\n\n# webservers\n{% for host in groups['webservers'] %}\n{{ hostvars[host]['ansible_host'] }} {{ hostvars[host]['inventory_hostname'] }}\n{% endfor %}\n</code></pre> <pre><code>all:\nhosts:\nchildren:\n    webserver:\n    hosts:\n        server1:\n        server2:\n        server3:\n</code></pre> <pre><code>- name: \"DNS setup\"\n  hosts: webserver\n  tasks:\n  - name: \"Create hosts file \"\n    template: \n      src: hosts.j2\n      dest: /etc/hosts\n</code></pre> <pre><code># localhost\n127.0.0.1 localhost\n10.0.0.1 server1\n\n# webservers\n10.0.0.1 server1\n10.0.0.2 server2\n10.0.0.3 server3\n</code></pre> <pre><code># localhost\n127.0.0.1 localhost\n10.0.0.1 server2\n\n# webservers\n10.0.0.1 server1\n10.0.0.2 server2\n10.0.0.3 server3\n</code></pre> <pre><code># localhost\n127.0.0.1 localhost\n10.0.0.1 server3\n\n# webservers\n10.0.0.1 server1\n10.0.0.2 server2\n10.0.0.3 server3\n</code></pre>"},{"location":"basics/modules/template/#advanced-example","title":"Advanced example","text":"<p>You can expand the template module with a lot of features. This is an example for a nftables firewall template:</p> nftables-firewall.yml <pre><code>table ip filter {\nset trusted {\ntypeof ip saddr\nelements = {10.22.0.50, 10.22.0.51, 10.22.0.52}\n}\n\nchain input {\ntype filter hook input priority filter; policy drop;\nct state related,established counter accept\n\n#Trusted (icmp and ssh)\nip saddr @trusted tcp dport 22 counter accept\nip saddr @trusted ip protocol icmp counter accept\n\n#DNS Incomming all (all to dns udp port 53)\n{% if inventory_hostname in groups['dns'] %}\nudp dport 53 counter accept\n{% endif %}\n\n#DNS replication (dns to dns-master tcp 53 )\n{% if inventory_hostname in groups['dns'][0] %}\n{% for h in groups['dns'] %}\n{% if inventory_hostname not in hostvars[h]['inventory_hostname'] %}\nip saddr {{hostvars[h]['ansible_host']}} tcp dport 53 counter accept\n{% endif %}\n{% endfor %}\n{% endif %}\n\n#DNS Management (localhost)\niif lo counter accept\n\n#Web Traffic (all to port webport)\n{% if inventory_hostname in groups['web'] %}\ntcp dport {{ webport }} counter accept\n{% endif %}\n\n#Proxy to Web Traffic (ha to web port 8081)\n{% if inventory_hostname in groups['web'] %}\n{% for h in groups['ha'] %}\nip saddr {{hostvars[h]['ansible_host']}} tcp dport 8081 counter accept\n{% endfor %}\n{% endif %}\n\n}\n</code></pre>"},{"location":"basics/modules/template/#reference","title":"Reference","text":"<p>Ansible docs - template module</p>"},{"location":"basics/secrets/vault/","title":"Ansible vault","text":"<p>Ansible vault allows you to encrypt sensitive data such as passwords or API keys. This is useful if you want to store your Ansible playbooks in a public repository.</p> <p>Ansible vault is integrated in Ansible and can be used in combination.</p>"},{"location":"basics/secrets/vault/#setting-up-ansible-vault","title":"Setting up Ansible vault","text":"<p>To use Ansible vault, you need to create a vault password file. This file contains the password that is used to encrypt and decrypt the vault files. The vault password file should never be committed to a git repository. The vault password file can also be an executable script that returns the password on stdout.</p> .vault-pass<pre><code>mysecretpassword\n</code></pre> ansible.cfg<pre><code>[defaults]\nvault_password_file = .vault-pass\n</code></pre>"},{"location":"basics/secrets/vault/#encrypting-files","title":"Encrypting files","text":"<p>You can use the <code>ansible-vault encrypt/decrypt</code> command to encrypt/decrypt files. <pre><code>ansible-vault encrypt mysecretfile\nansible-vault decrypt mysecretfile\n</code></pre></p> <p>When running an Ansible playbook, you can also use the <code>--ask-vault-pass</code> flag to enter the vault password. Ansible will automatically decrypt the vault files when running the playbook.</p> <p>An encrypted Ansible vault file will look like this: mysecretfile<pre><code>$ANSIBLE_VAULT;1.1;AES256\n38643762643366326564356637313332613431636664353133323665393231323839343839653136\n6464306164356432656537356263336362373166386639620a353132396535633062663533366430\n65376635366539636262613964326265626536383138626664363134396433376266653931343135\n3931323438393236350a633839623764623765393634646331366634326562373730643934333732\n3133\n</code></pre></p>"},{"location":"basics/secrets/vault/#reference","title":"Reference","text":"<p>Ansible vault</p>"},{"location":"basics/tasks/check-diff/","title":"Check and diff mode","text":"<p>Ansible allows you to run a playbook in check and mode. This will not make any changes to the system, but will show you what changes would be made if you would run the playbook without check mode.</p> <p>This can be very useful if you want to check if your playbook is idempotent or if you want to see what changes would be made to your system.</p>"},{"location":"basics/tasks/check-diff/#check-mode","title":"Check mode","text":"<p>Check mode will run the playbook and not make any changes to the system.  It will show you if changes would be made. Check mode can be enabled by using the <code>--check</code> flag when running the playbook.</p> <pre><code>ansible-playbook playbook.yml --check\n</code></pre>"},{"location":"basics/tasks/check-diff/#diff-mode","title":"Diff mode","text":"<p>Diff mode will show you the changes that are be made to the system. The Ansible module needs to support diff mode to show a clean output of the changes done. <pre><code>ansible-playbook playbook.yml --diff\n</code></pre></p>"},{"location":"basics/tasks/check-diff/#using-check-and-diff-mode-together","title":"Using check and diff mode together","text":"<p>This is the most useful way to check your playbook. It show all changes that would be made to the system but will not make any changes to the system. <pre><code>ansible-playbook playbook.yml --check --diff\n</code></pre></p> <p>This is an example of the output of a playbook that is run in check and diff mode with the template module:</p> <p></p>"},{"location":"basics/tasks/check-diff/#reference","title":"Reference","text":"<p>Ansible check and diff mode</p>"},{"location":"basics/tasks/delegate/","title":"Delegating tasks","text":"<p>By default all ansible tasks are run on the host specified in the inventory file. Sometimes you may want to run a task on a different host than the one you are currently iterating over. This is called delegating a task.</p>"},{"location":"basics/tasks/delegate/#delegate-to-a-specific-host","title":"Delegate to a specific host","text":"<p>This task reads a file on localhost and copies its contents to a remote host.</p> playbook-with-delegation.yml<pre><code>- name: myplay\n  hosts: webserver1\n  tasks:\n  - name: read a file from localhost\n    command:\n      cmd: cat /etc/hosts\n    delegate_to: localhost\n    register: _file_localhost\n\n  - name: create a file on the webserver\n    shell:\n      cmd: \"echo '{{ _file_localhost.stdout }}' &gt; /tmp/file.txt\"\n</code></pre>"},{"location":"basics/tasks/delegate/#delegate-facts","title":"Delegate facts","text":"<p>As you can see in the example above, all gathered facts are available on the current host, that we are iterating over. If we want to attach the facts to the delegated host, we can use the <code>delegate_facts</code> option.</p> playbook-with-delegated-facts.yml<pre><code>- name: myplay\n  hosts: webserver1\n  tasks:\n  - name: read a file from localhost\n    command:\n      cmd: cat /etc/hosts\n    delegate_to: localhost\n    delegate_facts: true\n    register: _file_localhost\n\n  - name: create a file on the webserver\n    shell:\n      cmd: \"echo '{{ hostvars['localhost']['_file_localhost']['stdout'] }}' &gt; /tmp/file.txt\"\n</code></pre>"},{"location":"basics/tasks/delegate/#reference","title":"Reference","text":"<p>Ansible docs - Delegate tasks</p>"},{"location":"basics/tasks/first-task/","title":"Running your first ansible tasks","text":""},{"location":"basics/tasks/first-task/#creating-a-file","title":"Creating a file","text":"<p>This task will create a file called <code>note.txt</code> in the <code>/tmp</code> directory on your localhost. create-file.yml<pre><code>- name: \"First Play\"\n  hosts: localhost\n  tasks:\n    - name: \"First task\"\n      command: touch /tmp/note.txt\n</code></pre></p> <p>The playbook will be run with the following command: <pre><code>ansible-playbook create-file.yml\n</code></pre></p> <p>This task uses the <code>command</code> module to run the <code>touch</code> command on the local host.</p>"},{"location":"basics/tasks/first-task/#copying-a-file-to-a-remote-system","title":"Copying a file to a remote system","text":"<p>This task will copy the file from before to <code>/tmp/note2.txt</code>. copy-file.yml<pre><code>- name: \"Second Play\"\n  hosts: localhost\n  tasks:\n    - name: \"Second task\"\n      copy: \n        src: /tmp/note.txt\n        dest: /tmp/note2.txt\n</code></pre></p> <p>The playbook will be run with the following command: <pre><code>ansible-playbook copy-file.yml\n</code></pre></p> <p>This task uses the builtin <code>copy</code> module.</p>"},{"location":"basics/tasks/first-task/#analysing-the-output","title":"Analysing the output","text":"<p>The output of the second playbook will look something like this: <pre><code>PLAY [Second task] **************************************************************************************************\n\nTASK [Gathering Facts] **********************************************************************************************\nok: [localhost]\n\nTASK [Second task] **************************************************************************************************\nchanged: [localhost]\n\nPLAY RECAP **********************************************************************************************************\nlocalhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n</code></pre></p> <p>If we run the second playbook again, the output will look like this: <pre><code>PLAY [Second task] **************************************************************************************************\n\nTASK [Gathering Facts] **********************************************************************************************\nok: [localhost]\n\nTASK [Second task] **************************************************************************************************\nok: [localhost]\n\nPLAY RECAP **********************************************************************************************************\nlocalhost                  : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n</code></pre></p> <p>The second run shows status ok, because the copy module is idempotent.  Because the file was already copied, the module did not change anything. More details about the playbook recap will follow in the next chapters.</p>"},{"location":"basics/tasks/gather-facts/","title":"Gathering ansible facts","text":"<p>Gathering facts means, that ansible connects to all hosts of the play and collects information about the host. This information is stored in the variable <code>ansible_facts</code>. This variable is a dictionary and contains information about the host, like the operating system, the hostname, the IP address, the CPU architecture, and so on. </p> <p>Gathered facts can be used later in the playbook. For example you can make config changes depending on the operating system of the host.</p>"},{"location":"basics/tasks/gather-facts/#showing-gathered-facts-with-the-debug-module","title":"Showing gathered facts with the <code>debug</code> module","text":"gather-facts.yml<pre><code>- name: \"My play\"\n  hosts: localhost\n  tasks:\n    - name: \"Show facts\"\n      debug: \n        var: ansible_facts\n</code></pre> <p>Running the playbook to gather facts: <pre><code>ansible-playbook gather-facts.yml\n</code></pre></p> <p>Resulting output: <pre><code>PLAY [My play] *****************************************************************\n\nTASK [Gathering Facts] *********************************************************\nok: [localhost]\n\nTASK [Show facts] **************************************************************\nok: [localhost] =&gt; {\n    \"ansible_facts\": {\n        \"all_ipv4_addresses\": [\n            \"10.0.0.1\"\n        ],\n        \"all_ipv6_addresses\": [\n            \"fe80::215:251:2131:531\"\n        ],\n        \"ansible_local\": {},\n        \"apparmor\": {\n            \"status\": \"disabled\"\n        },\n        \"architecture\": \"x86_64\",\n        \"bios_date\": \"NA\",\n        \"bios_vendor\": \"NA\",\n        \"bios_version\": \"NA\",\n        \"board_asset_tag\": \"NA\",\n        ...\n</code></pre></p> <p>It is recommended to disable facts gathering, if you don't need the facts. This improves the performance of the playbook massively.</p> <p>You can manually disable facts gathering with the <code>gather_facts</code> option: <pre><code>- name: \"My play\"\n  hosts: localhost\n  gather_facts: false\n  tasks:\n    - name: \"Show facts\"\n      debug: \n        var: ansible_facts\n</code></pre></p>"},{"location":"basics/tasks/gather-facts/#reference","title":"Reference","text":"<p>Ansible docs - gather_facts module</p>"},{"location":"basics/tasks/handlers/","title":"Handlers","text":"<p>Handlers in ansible are tasks that are triggered by a notification. A notification is sent by a task, and the handler will be run after the task has finished. This is useful for restarting services, or other tasks that should only be run after a change has been made.</p> <p>Good examples for handlers are:</p> <ul> <li>Restarting Nginx service after config change</li> <li>Reboot after installing a new kernel</li> </ul>"},{"location":"basics/tasks/handlers/#defining-handlers","title":"Defining handlers","text":"<p>Handlers can be in a separate file, if you use the production directory structure. For small playbooks, you can also define them in the same file as the tasks.</p> nginx-setup.yml<pre><code>- name: setup nginx\n  hosts: webserver\n  tasks:\n  ...\n\n  handlers:\n    - name: restart nginx\n      service:\n        name: nginx\n        state: restarted\n</code></pre>"},{"location":"basics/tasks/handlers/#running-handlers","title":"Running handlers","text":"<p>To run the handlers, you need to notify them in a task. The notification will only occur, if the task has status changed.  The task will be run, and after it has finished, the handler will be run. If you have multiple tasks notifing the same handler, the handler will only be run once at the end of the play.</p> nginx-setup.yml<pre><code>- name: setup nginx\n  hosts: webserver\n  tasks:\n    - name: copy nginx config\n      template:\n        src: nginx.conf.j2\n        dest: /etc/nginx/nginx.conf\n      notify: restart nginx\n\n  handlers:\n    - name: restart nginx\n      service:\n        name: nginx\n        state: restarted\n</code></pre>"},{"location":"basics/tasks/handlers/#running-handlers-during-a-play","title":"Running handlers during a play","text":"<p>If you want to run a handler during a play, you can use the <code>meta: flush_handlers</code> task. This will run all handlers that have been notified until that point.</p> nginx-setup.yml<pre><code>- name: setup nginx\n  hosts: webserver\n  tasks:\n    - name: copy nginx config\n      template:\n        src: nginx.conf.j2\n        dest: /etc/nginx/nginx.conf\n      notify: restart nginx\n\n    - name: Flush all pending handlers\n      meta: flush_handlers\n\n      ...\n\n  handlers:\n    - name: restart nginx\n      service:\n        name: nginx\n        state: restarted\n</code></pre>"},{"location":"basics/tasks/handlers/#running-multiple-handlers","title":"Running multiple handlers","text":"<p>If you have multiple handlers, you can run them by using the <code>listen</code> keyword. This will group the handlers in a single notification called <code>restart web services</code>. <pre><code>tasks:\n  - name: Restart everything\n    command: echo \"this task will restart the web services\"\n    notify: \"restart web services\"\n\nhandlers:\n  - name: Restart memcached\n    service:\n      name: memcached\n      state: restarted\n    listen: \"restart web services\"\n\n  - name: Restart apache\n    service:\n      name: apache\n      state: restarted\n    listen: \"restart web services\"\n</code></pre></p> <p>You can also notify multiple handlers in a single task. <pre><code>tasks:\n  - name: Restart everything\n    command: echo \"this task will restart the web services\"\n    notify: \n    - \"Restart memcached\"\n    - \"Restart apache\"\n</code></pre></p>"},{"location":"basics/tasks/handlers/#reference","title":"Reference","text":"<p>Ansible docs - handlers</p>"},{"location":"basics/tasks/recap/","title":"Result of a playbook run","text":"<p>Every task in a playbook returns a state. Possible states are:</p> <ul> <li>ok</li> <li>changed</li> <li>unreachable</li> <li>failed</li> <li>skipped</li> <li>rescued</li> <li>ignored</li> </ul> Example result of a play <pre><code>PLAY RECAP *********************************************************************\nserver1     : ok=28   changed=1    unreachable=0    failed=0    skipped=10   rescued=0    ignored=0   \nserver2     : ok=26   changed=1    unreachable=0    failed=0    skipped=10   rescued=0    ignored=0   \nserver3     : ok=26   changed=1    unreachable=0    failed=0    skipped=8    rescued=0    ignored=0   \nserver4     : ok=25   changed=1    unreachable=0    failed=0    skipped=8    rescued=0    ignored=0   \nserver5     : ok=25   changed=1    unreachable=0    failed=0    skipped=7    rescued=0    ignored=0   \n</code></pre> <p>Based on the state you will know, if the playbook run was successful or not.</p>"},{"location":"basics/tasks/recap/#modifing-the-result-of-a-task","title":"Modifing the result of a task","text":"<p>You can override the result of a task by using the <code>changed_when</code> and <code>failed_when</code> keywords. This can be usefull if you for example want a task to never be marked as changed.</p> never-change.yml<pre><code>- name: Hello World\n  shell:\n    command: echo \"hello\"\n  changed_when: false\n</code></pre> change-if.yml<pre><code>- name: Hello World\n  shell:\n    command: echo \"hello\"\n  register: result\n  changed_when: result.stdout == \"hello\"\n</code></pre>"},{"location":"basics/tasks/recap/#behaviour-of-a-task-on-failure","title":"Behaviour of a task on failure","text":"<p>If a task fails, no other task will be executed on this host. All other hosts will continue to execute their tasks.</p> <p>You can change this behaviour by using the <code>ignore_errors</code> keyword.</p>"},{"location":"basics/tasks/return/","title":"Registering task results","text":"<p>You can register the return of a task to use it later in the playbook.</p> register.yml<pre><code>- name: Register result\n  shell:\n    command: echo \"hello\"\n  register: result\n\n- name: Show result\n  debug:\n    var: result\n</code></pre> <p>There are some common variables that you will find in the <code>result</code> variable. For example:</p> <ul> <li>changed</li> <li>failed</li> <li>msg</li> <li>rc</li> <li>results</li> <li>skipped</li> <li>stderr</li> <li>stderr_lines</li> <li>stdout</li> <li>stdout_lines</li> </ul> output<pre><code>TASK [Register result] ******************************************\nchanged: [localhost]\n\nTASK [Show result] **********************************************\nok: [localhost] =&gt; {\n    \"result\": {\n        \"changed\": true,\n        \"cmd\": \"echo \\\"hello\\\"\",\n        \"delta\": \"0:00:00.002058\",\n        \"end\": \"2023-03-10 11:10:17.866992\",\n        \"failed\": false,\n        \"msg\": \"\",\n        \"rc\": 0, # (1)\n        \"start\": \"2023-03-10 11:10:17.864934\",\n        \"stderr\": \"\",\n        \"stderr_lines\": [],\n        \"stdout\": \"hello\",\n        \"stdout_lines\": [\n            \"hello\"\n        ]\n    }\n}\n</code></pre> <ol> <li><code>rc</code> stands for return code. It is the exit code of the command.     This is very usefull because you can run code based upon the exit code of a command.</li> </ol>"},{"location":"basics/tasks/tags/","title":"Tags","text":"<p>Ansible tags allow you to run only specific tasks in a playbook. This is useful if you want to run only a specific part of a playbook.</p>"},{"location":"basics/tasks/tags/#apply-tags-to-tasks","title":"Apply tags to tasks","text":"<p>You can apply one or more tags to tasks in a playbook like this:</p> <p><pre><code>tasks:\n- name: Task with tag1 and tag2\n  ansible.builtin.debug:\n    msg: \"This task is tagged with 'test'\"\n  tags:\n    - tag1\n    - tag2\n</code></pre> You can also apply tags to roles, playbooks and includes.</p>"},{"location":"basics/tasks/tags/#running-playbook-with-tags","title":"Running playbook with tags","text":"<p>By default ansible will run all tasks regardless of the tags. You can specify tags to run on the command line like this:</p> <p><pre><code>ansible-playbook playbook.yml --tag \"tag1\"\n</code></pre> When you specify a tag on the command line, ansible will only run tasks that have that tag. These are other options for specifying tags on the command line:</p> <pre><code>--tags all               #run all tasks, ignore tags (default behavior)\n--tags [tag1, tag2]      #run only tasks with either the tag tag1 or the tag tag2\n--skip-tags [tag3, tag4] #run all tasks except those with either the tag tag3 or the tag tag4\n--tags tagged            #run only tasks with at least one tag\n--tags untagged          #run only tasks with no tags\n</code></pre>"},{"location":"basics/tasks/tags/#inheritance","title":"Inheritance","text":"<p>Ansible does not inherit tags for the <code>include_role</code> and <code>include_tasks</code> modules. This means that you have to manually enforce inheritance like this:</p> <pre><code>- name: Apply the db tag to the include and to all tasks in db.yml\n  include_tasks:\n    file: db.yml\n    # adds 'db' tag to tasks within db.yml\n    apply:\n      tags: db\n  # adds 'db' tag to this 'include_tasks' itself\n  tags: db\n</code></pre> <p>or you can create a block to apply the tag to all tasks in the block:</p> <pre><code>- block:\n   - name: Include tasks from db.yml\n     include_tasks: db.yml\n  tags: db\n</code></pre>"},{"location":"basics/tasks/tags/#special-tags","title":"Special tags","text":"<p><code>Always</code> and <code>Never</code> are special tags that can be used to run tasks regardless of the tags specified on the command line.</p> <pre><code>tasks:\n- name: Print a message\n  ansible.builtin.debug:\n    msg: \"Always runs\"\n  tags:\n  - always\n\n- name: Print a message\n  ansible.builtin.debug:\n    msg: \"Never runs\"\n  tags:\n  - never\n</code></pre>"},{"location":"basics/tasks/tags/#reference","title":"Reference","text":"<p>Tags - Ansible docs</p>"},{"location":"examples/","title":"Examples","text":"<p>These are some examples of ansible playbooks.</p> <p>You can find official ansible examples here to get some more inspiration.</p>"},{"location":"examples/cisco/acl/","title":"Cisco ACL example","text":"<p>This example configures an ACL on a Cisco IOS device. It allows all ip adresses to access the device via SSH, HTTPS and ICMP on GigabitEthernet1. For proper indempotence the ACL is preconfigured with a unique number for each line.</p> <pre><code>ios_config: \n    lines: \n    - \"{{ (item.0 + 1)*10 + 1 }}\" permit tcp host {{ item.1 }} any eq 22\"\n    - \"{{ (item.0 + 1)*10 + 2 }}\" permit tcp host {{ item.1 }} any eq 443\"\n    - \"{{ (item.0 + 1)*10 + 3 }}\" permit icmp host {{ item.1 }} any\"\n    parents: ip access-list extended aclmgmt\n    save_when: changed\nwith_indexed_items:\n- 10.0.0.100\n- 10.0.0.101\n- 10.0.0.102\n\nios_config: \n    lines: ip access-group aclmgmt in\n    parents: interface GigabitEthernet1\nsave_when: changed\n</code></pre>"},{"location":"examples/cisco/interface/","title":"Cisco interface example","text":"<p>This example configures a lopback interface on a Cisco IOS device. It assigns the IP address of the loopback interface based on the index of the host in the group.</p> <pre><code># Variable defined for all cisco devices\nloop_net: 10.0.0.0/24\n\n#task\nios_config:\n lines:\n - \"ip address {{ loop_net | ipmath(groups.cisco.index(inventory_hostname))}} 255.255.255.255\"\n - \"description Ansible - Loopback Interface\"\n parents: interface Loopback0\n save_when: changed\n</code></pre>"},{"location":"examples/linux/dns-server/","title":"Linux bind9 dns server example","text":"<p>This example configures a bind9 dns server on Linux hosts. The first host in the inventory is the master dns server. All other hosts are configured as slave dns servers. It adds all host from the inventory as dns entries.</p> playbook.ymlinventory.ymldb.empty.j2named.conf.local.j2 <pre><code>- name: configure dns server\n  hosts: dns\n  gather_facts: false\n  tasks:\n\n  - name: apt | install bind9\n    apt: \n      name: bind9\n      state: present\n\n  - name: template | dns database file\n    template:\n      src: files/dns/db.empty.j2\n      dest: /etc/bind/db.comp\n    when: inventory_hostname == groups['dns'][0]\n    register: dnsdb\n\n  - name: template | dns config file\n    template:\n      src: files/dns/named.conf.local.j2\n      dest: /etc/bind/named.conf.local\n    register: dnsconf\n\n  - name: service | restart dns server\n    service:\n      name: bind9\n      state: restarted\n    when: dnsconf.changed or dnsdb.changed\n</code></pre> <pre><code>all:\nhosts:\n    LIN1:\n        ansible_host: 10.0.0.1\n        hostname: \"COMP-LINUXHOST-001\"\n    LIN2:\n        ansible_host: 10.0.0.2\n        hostname: \"COMP-LINUXHOST-002\"\n    LIN3:\n        ansible_host: 10.0.0.3\n        hostname: \"COMP-LINUXHOST-003\"\nchildren:\n    dns:\n        hosts:\n            LIN1:\n            LIN2:\n            LIN3:\n</code></pre> <pre><code>;\n; Generated by ansible \n;\n\n$TTL    86400\n@   IN  SOA localhost. root.localhost. (\n                1       ; Serial\n            604800      ; Refresh\n            86400       ; Retry\n            2419200     ; Expire\n            86400 ) ; Negative Cache TTL\n\n@   IN  NS  localhost.\n\n;ansible host records\n{% for host in groups['all'] %}\n{{ hostvars[host]['hostname'] }} IN A {{ hostvars[host]['ansible_host'] }}\n{% endfor %}\n\n;static records\napi         IN  A   10.0.0.10\nintranet    IN  A   10.0.0.11\n</code></pre> <pre><code>zone \"comp.com\" {\n{% if inventory_hostname in hostvars[groups['dns'][0]]['inventory_hostname'] %}\ntype master;\nfile \"/etc/bind/db.comp\";\nallow-transfer { any; };\n{% else %}\ntype slave;\nmasters { {{ hostvars[groups['dns'][0]]['ansible_host'] }}; };\n{% endif %}\n};\n</code></pre>"},{"location":"examples/linux/update-system/","title":"Linux update system","text":"<p>This example shows how to update linux using the apt package manager.</p> update-system.yml<pre><code>- name: Update linux hosts\n  hosts: linux\n  gather_facts: false\n  tasks: \n\n  - name: Apt | update all packages\n    ansible.builtin.apt:\n      upgrade: true\n      update_cache: true\n\n  - name: State | check if reboot is needed\n    stat: \n      path: /var/run/reboot-required\n    register: check_reboot\n\n  - name: Reboot | reboot host\n    ansible.builtin.reboot:\n      post_reboot_delay: 30\n    when: check_reboot.stat.exists\n</code></pre>"},{"location":"examples/linux/users/","title":"Linux unix users example","text":"<p>This example adds users to linux hosts. The password will not be changed, if the user already exists.</p> playbook.ymlusers.csv <pre><code>- name: Configure Users\n  hosts: linux\n  gather_facts: false\n  tasks: \n\n  - name: csv | read users file\n    read_csv:\n      path: /path/to/users.csv\n      delimiter: ';'\n    register: csv_users\n    delegate_to: localhost\n\n  - name: user | add users from csv \n    user:\n      name: \"{{ item.username }}\"\n      uid: \"{{ item.uid }}\"\n      home: \"{{ item.home }}\"\n      password: \"{{ item.password | password_hash('sha512') }}\"\n      update_password: on_create\n    with_items: \"{{ csv_users.list }}\"\n    loop_control:\n      label: \"{{ item.uid }}\"\n</code></pre> <pre><code>username;uid;home;password\nuser1;1001;/home/user1;password1\nuser2;1002;/home/user2;password2\nuser3;1003;/home/user3;password3\n</code></pre>"},{"location":"examples/windows/dns-record/","title":"Windows dns record","text":"<p>This example shows how to add DNS records based on a json customer list.</p> playbook.ymlcustomers.json <pre><code>#Import json\nshell: \"cat /path/to/customers.json\"\ndelegate_to: localhost\nregister: data\n\n# Set fact\nset_fact:\n  customers: \"{{ data.stdout | from_json }}\"\n\n#DNS\nwin_dns_record:\n  zone: customers.com \n  type: A\n  name: \"{{ item.domain_prefix }}\"\n  value: \"{{ item.ip }}\"\nwith_items: \"{{ customers }}\"\n</code></pre> <pre><code>[\n    {\n        \"name\": \"Art Gallery\",\n        \"domain_prefix\": \"art\",\n        \"ip\": \"10.0.0.4\"\n    },\n    {\n        \"name\": \"Retail Store\",\n        \"domain_prefix\": \"store\",\n        \"ip\": \"10.0.0.5\"\n    }\n]\n</code></pre>"},{"location":"examples/windows/domain-setup/","title":"Windows domain setup","text":"<p>This example shows how to setup a Windows domain controller and join other domain controllers. The join the rest of the hosts to the domain.</p> <p>Warning</p> <p>This example is only for demonstration purposes. Make sure to change flow according to your needs.</p> playbook.yml<pre><code>#ADDS installation on all DCs\nwin_feature:\n    state: present\n    name: AD-Domain-Services\n    include_sub_features: yes\n\n#PDC Setup\nwin_domain:\n    dns_domain_name: customers.com\n    safe_mode_password: \"{{ ansible_password }}\"\nwhen: inventory_hostname in groups['dns'][0]\nregister: pdc\n\n#Reboot when: pdc.changed\nansible.windows.win_reboot:\n  reboot_timeout: 60\nwhen: pdc.changed\n\n#Wait for DC to be back (takes aprox. 8 minutes // up to 15 minutes)\nname: Wait for domain controller to be ready\nwin_shell: |\n    Get-ADDomain customers.com\nregister: dc_ready\nuntil: dc_ready is not failed\nignore_errors: yes\nretries: 180\ndelay: 5\nwhen: pdc.changed\n\n#Domain Join other DCs\nwin_domain_controller:\n    state: domain_controller\n    dns_domain_name: customers.com\n    domain_admin_user: \"{{ ansible_user }}@customers.com\"\n    domain_admin_password: \"{{ ansible_password }}\"\n    safe_mode_password: \"{{ ansible_password }}\"\nwhen: inventory_hostname is not groups['dns'][0]\nregister: dc\n\n#Reboot when: dc.changed\nansible.windows.win_reboot:\n  reboot_timeout: 60\nwhen: dc.changed\n\n#Domain Join Members\nwin_domain_membership:\n    state: domain\n    dns_domain_name: customers.com\n    domain_admin_user: \"{{ ansible_user }}@customers.com\"\n    domain_admin_password: \"{{ ansible_password }}\"\nwhen: \"'dc' not in group_names\"\nregister: domainjoin\n\n#Reboot when: domainjoin.changed\nansible.windows.win_reboot:\n  reboot_timeout: 60\nwhen: domainjoin.changed\n</code></pre>"},{"location":"explained/","title":"What is Ansible?","text":"<p>Ansible is a configuration management tool. It allows you to configure remote systems in a declarative way. It is agentless and uses SSH, WinRM or HTTPS to connect to remote systems. Ansible is written in Python and runs on Linux, MacOS and Windows(WSL). Windows native is not supported.</p> <p>Ansible is open-source and maintained by RedHat. Therefore it is completely free to use. It is also available as a commercial product with advanced called Ansible Tower directly from RedHat.</p>"},{"location":"explained/#why-not-use-scripts-to-configure-remote-systems","title":"Why not use scripts to configure remote systems?","text":"<p>Ansible offeres a lot of advantages over scripts. It is agentless, declarative and idempotent. It is also very easy to use and extend. Ansible has a big community and a lot of modules and plugins. Ansible has built-in parallelism. So you can update multiple systems at the same time. Because Ansible allows you to configure not only servers but also network devices, it is a good tool for multiple aspects.</p>"},{"location":"explained/concepts/","title":"Concepts","text":""},{"location":"explained/concepts/#task","title":"Task","text":"<p>A task is the smallest unit of work in Ansible. It is a single command or action that is executed on a single host. A task can be as simple as a command to copy a file or as complex as a loop that iterates over a list of items. <pre><code>- name: task1\n  command: echo \"Hello World\"\n</code></pre></p>"},{"location":"explained/concepts/#playbook","title":"Playbook","text":"<p>A playbook is a YAML file that contains a list of plays. A play is a collection of tasks that are executed on a single or multiple hosts. playbook.yml<pre><code>- name: myplay1\n  hosts: webserver\n  tasks:\n    - name: task1\n      command: echo \"Hello World\"\n</code></pre></p>"},{"location":"explained/concepts/#module","title":"Module","text":"<p>A module is a self-contained script that implements a specific feature. Modules are the building blocks of Ansible. They can be executed directly on the command line or in a playbook. Modules can be written in any programming language. The most common languages are Python and Powershell. Examples for often used modules are command and template. <pre><code>name: Task using the command module\ncommand: echo \"Hello World\"\n\nname: Task using the template module\ntemplate:\n  src: template.j2\n  dest: /tmp/template.txt\n</code></pre></p>"},{"location":"explained/concepts/#role","title":"Role","text":"<p>A role is a collection of tasks and files that are executed on a single or multiple hosts. Roles are often used to configure a specific service or application. For example a webserver role could install nginx and configure host firewall settings.</p>"},{"location":"explained/concepts/#collection","title":"Collection","text":"<p>A collection is a distribution format for Ansible content. It can be a role, a module or a plugin. A collection can be published on Ansible Galaxy and installed with the ansible-galaxy command. Most vendors that provide Ansible content publish their content as a collection. The most popular collections are documented directly on the Ansible documentation page. </p>"},{"location":"explained/docs/","title":"Ansible documentation","text":"<p>You can find the full community documentation for Ansible here.</p>"},{"location":"explained/docs/#module-documentation","title":"Module documentation","text":"<p>All ansible modules/collections are documented here.</p> <p>Example for the ansible copy module: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/copy_module.html</p> <p>Ansible modules are documented in the following chapters:</p> Chapter Description Synopsis Some general comments about the module and what it does Parameters All possible paramters that can be set Examples Some example files on how to use this module. Watch out sometimes  the examples contain outdated parameters Return Values What the module returns when it is executed Authors Who wrote the module"},{"location":"explained/files/","title":"Ansible files","text":"<p>Ansible files used for running Ansible can generally be split into three categories: configuration, content and inventory files.</p>"},{"location":"explained/files/#configuration","title":"Configuration","text":"<p>The configuration files define, how the Ansible binary behaves. Here you can configure settings like the location of the inventory file, the location of the SSH key or the location of the Ansible modules.</p> <p>Ansible looks in the following locations for configuration files:</p> <ul> <li>ANSIBLE_CONFIG (environment variable if set)</li> <li>ansible.cfg (INI file in the current directory)</li> <li>~/.ansible.cfg (INI file in the home directory)</li> <li>/etc/ansible/ansible.cfg (INI file)</li> </ul> <p>Reference for the configuration options: https://docs.ansible.com/ansible/latest/reference_appendices/config.html</p> Example configuration file ansible.cfg<pre><code>[defaults]\ninventory = ./inventory\nhost_key_checking = False\nremote_user = ansible\nprivate_key_file = ~/.ssh/id_rsa\nroles_path = ./roles\n</code></pre>"},{"location":"explained/files/#content","title":"Content","text":"<p>Content files are the files that are used by Ansible to configure the remote systems. Content files are YAML files. Content files can be playbooks that contain a list of plays or roles that contain a list of tasks.</p> Example content file playbook.yml<pre><code>- name: myplay1\n  hosts: webserver\n  tasks:\n    - name: task1\n      command: echo \"Hello World\"\n</code></pre>"},{"location":"explained/files/#inventory","title":"Inventory","text":"<p>The inventory files are YAML or INI files. The inventory files contain remote systems and variables defining the remote systems. . Variables can be directly defined in the inventory file or in a separate variables file.</p> Example inventory file YAMLINI inventory.yml<pre><code>all:\nhosts:\n    mail.example.com:\nchildren:\n    webservers:\n    hosts:\n        foo.example.com:\n        bar.example.com:\n    dbservers:\n        hosts:\n            one.example.com:\n            two.example.com:\n            three.example.com:\n</code></pre> inventory.ini<pre><code>mail.example.com\n\n[webservers]\nfoo.example.com\nbar.example.com\n\n[dbservers]\none.example.com\ntwo.example.com\nthree.example.com\n</code></pre>"},{"location":"explained/indempotency/","title":"Indempotency","text":"<p>Indempotency is a property of operations that guarantees that the operation can be executed multiple times without changing the result beyond the initial application.</p> <p> <sup>1</sup></p> <p>Almost every Ansible module is by default idempotent. This means that if you run the same task multiple times, the result will be the same. This is a very important property of Ansible. It allows you to run the same playbook multiple times without changing the result. This is very useful if you want to apply the same configuration to multiple systems. You can run the playbook multiple times without worrying about the result.</p> <ol> <li> <p>Process icons created by Uniconlabs - Flaticon \u21a9</p> </li> </ol>"},{"location":"explained/running-playbooks/","title":"Ansible control node","text":"<p>Ansible requires a control node to be run. The control node can be a server or your local computer. Ansible will connect to the remote systems directly from the control node, therefore network connectivity from the control node to the remote systems is required.</p> <p> <sup>1</sup></p> <p>The ansible binary is installed and run on the control node. The connection to the remote systems is established using SSH, WinRM or HTTPS.</p> <ol> <li> <p>Ansible Verwendungsszenarien \u21a9</p> </li> </ol>"},{"location":"setup/","title":"Setting up ansible","text":"<p>It is imporant to differentiate between a production and a development environment. </p> <p>For development purposes, you can use your local computer as a control node. This is the easiest way to get started with Ansible. You can also use a virtual machine or a container to run Ansible.</p> <p>In a production environment, you should use strict version control and run the playbooks from a central control node.</p>"},{"location":"setup/connecting/","title":"Connecting to hosts","text":"<p>Ansible can connect to hosts in different ways. This page describes the different connection types and how to configure them. For all connection types, you need to define the connection parameters in the Ansible variables. The connection parameters are different for each connection type.</p> <p>The ansible control node will always require network connectivity to the target host.</p>"},{"location":"setup/connecting/linux/","title":"Connecting to linux hosts","text":"<p>To connect to linux hosts, the remote host needs to have ssh enabled and a valid user login (password or publickey). In the Ansible configuration file, you can define the connection parameters:</p> ansible.cfg<pre><code>[defaults]\nhost_key_checking = false # Disable host key checking, only for testing\n</code></pre> variables per host<pre><code>ansible_host: myserver1 # IP or hostname\nansible_user: ansible-user\nansible_password: mypass # Password authentication\nansible_ssh_private_key_file: /home/ansible/.ssh/id_rsa # publickey authentication\n</code></pre>"},{"location":"setup/connecting/network-devices/","title":"Connecting to network devices","text":"<p>The connection to network devices is vendor specific. Most ansible modules use ssh, but more modern solutions connect using HTTPS to REST APIs.</p> <p>This is an example for connecting to a Cisco IOS device using ssh:</p> ansible.cfg<pre><code>[defaults]\nhost_key_checking = false # Disable host key checking, only for testing\n</code></pre> variables per network device<pre><code>ansible_host: myserver1 # IP or hostname\nansible_user: ansible-user\nansible_password: mypass # Password authentication\nansible_connection: network_cli\nansible_network_os: cisco.ios.ios\n</code></pre>"},{"location":"setup/connecting/windows/","title":"Connecting to windows hosts","text":"<p>To connect to windows hosts, the remote host needs to have WinRM enabled and a valid user login. Ansible provides a Powershell script to enable WinRM on a windows host. The script can be found here.</p> <p>In the Ansible variables, you can define the connection parameters:</p> variables per host<pre><code>ansible_host: myserver1 # IP or hostname\nansible_user: ansible-user\nansible_password: mypass # Password\nansible_connection: winrm # set winrm as connection type\nansible_winrm_server_cert_validation: ignore # ignore certificate validation, only for testing\n</code></pre>"},{"location":"setup/dev/","title":"Index","text":"<p>Note</p> <p>This is a demo setup guide for users starting with ansible.</p> <p>Never use this guide to setup ansible in production.</p>"},{"location":"setup/dev/#ansible-setup","title":"Ansible Setup","text":"<p>Ansible is developed in python and runs on Linux, MacOS and Windows(WSL). Windows native is not supported.</p>"},{"location":"setup/dev/#control-node","title":"Control Node","text":"<p>Ansible is an binary that can be installed via pip or apt. All configration is done via the control node. The control node can be your own local client or a remote management server.</p> <p></p>"},{"location":"setup/dev/control-node/","title":"Ansible Installation","text":"<p>Install Ansible on your local machine in the user space. It is not recommended to install ansible as root user.</p>"},{"location":"setup/dev/control-node/#pip","title":"pip","text":"<p>Make sure your system has python3 and pip installed. To install these packages on Ubuntu you can use the apt package manager: <pre><code>sudo apt install python3 python3-pip\n</code></pre></p> <p>Install ansible with pip: <pre><code>python3 -m pip install --user ansible\n</code></pre></p>"},{"location":"setup/dev/control-node/#path","title":"PATH","text":"<p>In some linux distros you need to add the ansible binary to your PATH. So you can run ansible from the command line directly. Run this command in your terminal: <pre><code>export PATH=\"/home/myuser/.local/bin:$PATH\"\n</code></pre></p>"},{"location":"setup/dev/control-node/#ansible-galaxy-content","title":"Ansible Galaxy Content","text":"<p>If you need to have additional features or content installed from Ansible galaxy, use the following commands: <pre><code>ansible-galaxy collection install collection.name\n</code></pre></p>"},{"location":"setup/prod/","title":"Index","text":"<p>Note</p> <p>This is a production setup guide for advanced users.</p> <p>Make sure you are familiar with the basic concepts of ansible.</p>"},{"location":"setup/prod/#ansible-setup","title":"Ansible Setup","text":"<p>Ansible is developed in python and runs on Linux, MacOS and Windows(WSL). Windows native is not supported.</p>"},{"location":"setup/prod/#control-node","title":"Control Node","text":"<p>Ansible is an binary that can be installed via pip or apt. All configration is done via the control node. The control node can be your own local client or a remote management server.</p> <p></p>"},{"location":"setup/prod/control-node/","title":"Ansible Installation","text":"<p>Install Ansible on your control node in the user space. It is not recommended to install ansible as root user.</p> <p>Your control node doesn't need to be a permanent server. You can also create a docker image and use CI/CD to run ansible playbooks.</p>"},{"location":"setup/prod/control-node/#pip","title":"pip","text":"<p>Make sure your system has python3 and pip installed. Use a requirements.txt file for keeping track of the version. <pre><code># requirements.txt\nansible==7.2.0\n\npython3 -m pip install --user -r requirements.txt\n</code></pre></p>"},{"location":"setup/prod/control-node/#path","title":"PATH","text":"<p>In some linux distros you need to add the ansible binary to your PATH. <pre><code>export PATH=\"/home/myuser/.local/bin:$PATH\"\n</code></pre></p>"},{"location":"setup/prod/control-node/#ansible-galaxy-content","title":"Ansible Galaxy Content","text":"<p>If you need to have additional features installed from Ansible galaxy, use the following approach. Create a requirements.yml file for keeping track of the version: <pre><code># requirements.yml\ncollections:\n- name: community.vmware\n  version: 3.4.0\n\nansible-galaxy install -r requirements.yml\n</code></pre></p>"},{"location":"setup/prod/directory-structure/","title":"Directory structure","text":"<p>Ansible is very flexible and you can structure your ansible project in many different ways. But there are some best practices that you should follow.</p> <p>Referencing files</p> <p>If you follow the recommended folder structure, you can reference files in your playbooks directly without having to include the full path: <pre><code>roles:\n- vm_base\n\nansible.builtin.include_tasks: \n  file: k8s-prereq.yml\n\nansible.builtin.template:\n  src: teleport.yaml.j2\n</code></pre></p> <p>This is the recommended folder structure layout for an Ansible project:</p> <pre><code>production                # inventory file for production servers\nstaging                   # inventory file for staging environment\n\ngroup_vars/\n   group1.yml             # here we assign variables to particular groups\n   group2.yml\nhost_vars/\n   hostname1.yml          # here we assign variables to particular systems\n   hostname2.yml\n\nlibrary/                  # if any custom modules, put them here (optional)\nmodule_utils/             # if any custom module_utils to support modules, put them here (optional)\nfilter_plugins/           # if any custom filter plugins, put them here (optional)\n\nsite.yml                  # master playbook\nwebservers.yml            # playbook for webserver tier\ndbservers.yml             # playbook for dbserver tier\n\nroles/\n    common/               # this hierarchy represents a \"role\"\n        tasks/            #\n            main.yml      #  &lt;-- tasks file can include smaller files if wanted\n        handlers/         #\n            main.yml      #  &lt;-- handlers file\n        templates/        #  &lt;-- files for use with the template resource\n            ntp.conf.j2   #  &lt;------- templates end in .j2\n        files/            #\n            bar.txt       #  &lt;-- files for use with the copy resource\n            foo.sh        #  &lt;-- script files for use with the script resource\n        vars/             #\n            main.yml      #  &lt;-- variables associated with this role\n        defaults/         #\n            main.yml      #  &lt;-- default lower priority variables for this role\n        meta/             #\n            main.yml      #  &lt;-- role dependencies\n        library/          # roles can also include custom modules\n        module_utils/     # roles can also include custom module_utils\n        lookup_plugins/   # or other types of plugins, like lookup in this case\n\n    webtier/              # same kind of structure as \"common\" was above, done for the webtier role\n    monitoring/           # \"\"\n    fooapp/               # \"\"\n</code></pre>"}]}